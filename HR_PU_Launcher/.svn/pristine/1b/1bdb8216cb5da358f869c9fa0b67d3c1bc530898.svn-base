/*
 * Copyright 2009 Cedric Priscal
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License. 
 */

package android_serialport_api;

import java.io.File;
import java.io.FileDescriptor;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.security.InvalidParameterException;
import java.util.Arrays;

import android.app.AlertDialog;
import android.content.DialogInterface;
import android.content.DialogInterface.OnClickListener;
import android.os.AsyncTask;
import android.os.Bundle;
import android.util.Log;
import android.view.View;


public class ThreadWrite {
	protected OutputStream mOutputStream;
	byte []mBuffer;
	
	public ThreadWrite(SerialPort mSerialPort) throws SecurityException, IOException {
		mOutputStream = mSerialPort.getOutputStream();
		mBuffer = new byte[1024];
		Arrays.fill(mBuffer, (byte) 0x55);
	}

//	@Override
//	public void run() {
//		while (!isInterrupted()) {
//			try {
//				if (mOutputStream != null) {
//					Log.d("debug", "=>> SendingThread : " + mBuffer);
//					mOutputStream.write(mBuffer);
//				} else {
//					return;
//				}
//			} catch (IOException e) {
//				e.printStackTrace();
//				return;
//			}
//		}
//	}
	
	public void mSendData(byte _cmd1, byte _cmd2, byte _byte)
	{
		byte data_size = 1;
		byte pBuf[] = new byte[data_size + HMSUartProtocol.PACKET_TOTAL_LEN];
		pBuf[HMSUartProtocol.INDEX_STOP] = HMSUartProtocol.SOP;
		pBuf[HMSUartProtocol.INDEX_TYPE] = HMSUartProtocol.TYPE;
		pBuf[HMSUartProtocol.INDEX_LEN] = (byte)(data_size + HMSUartProtocol.PACKET_CMD_TO_CS);
		pBuf[HMSUartProtocol.INDEX_CMD1] = _cmd1;
		pBuf[HMSUartProtocol.INDEX_CMD2] = _cmd2;
		pBuf[HMSUartProtocol.INDEX_DATA] = _byte;
		pBuf[data_size + HMSUartProtocol.PACKET_TOTAL_LEN - 2] = (HMSUartProtocol.MakeCRC(pBuf, pBuf[HMSUartProtocol.INDEX_LEN]));
		pBuf[data_size + HMSUartProtocol.PACKET_TOTAL_LEN - 1] = HMSUartProtocol.EOP;
		
		new MUpgradeWriteAsyncTask(pBuf).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
	}
	
	public void mSendData(byte _cmd1, byte _cmd2, byte[] _byte)
	{
		Log.d("debug", "=>> data_size : " + _byte.length);
		int data_size = _byte.length;
		byte pBuf[] = new byte[data_size + HMSUartProtocol.PACKET_TOTAL_LEN];
		pBuf[HMSUartProtocol.INDEX_STOP] = HMSUartProtocol.SOP;
		pBuf[HMSUartProtocol.INDEX_TYPE] = HMSUartProtocol.TYPE;
		pBuf[HMSUartProtocol.INDEX_LEN] = (byte)(data_size + HMSUartProtocol.PACKET_CMD_TO_CS);
		pBuf[HMSUartProtocol.INDEX_CMD1] = _cmd1;
		pBuf[HMSUartProtocol.INDEX_CMD2] = _cmd2;

		for (int i = 0; i < data_size; i++) pBuf[HMSUartProtocol.INDEX_DATA+i] = _byte[i];
		pBuf[data_size + HMSUartProtocol.PACKET_TOTAL_LEN - 2] = (HMSUartProtocol.MakeCRC(pBuf, pBuf[HMSUartProtocol.INDEX_LEN]));
		pBuf[data_size + HMSUartProtocol.PACKET_TOTAL_LEN - 1] = HMSUartProtocol.EOP;
		
		new MUpgradeWriteAsyncTask(pBuf).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
	}
	
	private class MUpgradeWriteAsyncTask extends AsyncTask<Void, Void, Void> {
		final byte[] mBuf;
		public MUpgradeWriteAsyncTask(byte[] _buf) {
			mBuf = _buf;
		}
		
		@Override
		protected Void doInBackground(Void... _void) {
			try {
				if (mOutputStream != null) {
					toHexString("[2] HRPU -> PC : ", mBuf);
					mOutputStream.write(mBuf);
				} else {
//							return;
				}
			} catch (IOException e) {
				e.printStackTrace();
//						return;
			}
			return null;
		}

		@Override
		public void onPostExecute(Void _void) {
		}
	}
	
	public static void toHexString(String _tag, byte buf[]){
	      StringBuffer sb = new StringBuffer();
	      for (int i = 0; i < buf.length; i++) {
	          sb.append(Integer.toHexString(0x0100 + (buf[i] & 0x00FF)).substring(1));
	          sb.append(" ");
	      }
	      Log.d("debug", "=>> " + _tag + " : "+ sb.toString());
	  }
	
//	private void DisplayError(int resourceId) {
//		AlertDialog.Builder b = new AlertDialog.Builder(this);
//		b.setTitle("Error");
//		b.setMessage(resourceId);
//		b.setPositiveButton("OK", new OnClickListener() {
//			public void onClick(DialogInterface dialog, int which) {
//				SerialPortActivity.this.finish();
//			}
//		});
//		b.show();
//	}



//	protected abstract void onDataReceived(final byte[] buffer, final int size);

//	@Override
//	protected void onDestroy() {
//		if (mReadThread != null)
//			mReadThread.interrupt();
//		mApplication.closeSerialPort();
//		mSerialPort = null;
//		super.onDestroy();
//	}
}
