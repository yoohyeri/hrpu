
// MFCsrialportDlg.cpp : 구현 파일
//

#include "stdafx.h"
#include "MFCsrialport.h"
#include "MFCsrialportDlg.h"
#include "afxdialogex.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif


// CMFCsrialportDlg 대화 상자



CMFCsrialportDlg::CMFCsrialportDlg(CWnd* pParent /*=NULL*/)
	: CDialogEx(IDD_MFCSRIALPORT_DIALOG, pParent)
	, m_str_comport(_T(""))
	, m_str_baudrate(_T(""))
{
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CMFCsrialportDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialogEx::DoDataExchange(pDX);
	DDX_Control(pDX, IDC_COMBO_COMPORT, m_combo_comport_list);
	DDX_CBString(pDX, IDC_COMBO_COMPORT, m_str_comport);
	DDX_Control(pDX, IDC_EDIT_RCV_VIEW, m_edit_rcv_view);
	DDX_Control(pDX, IDC_EDIT_SEND_DATA, m_edit_send_data);
}

BEGIN_MESSAGE_MAP(CMFCsrialportDlg, CDialogEx)
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_WM_TIMER()

	ON_MESSAGE(WM_MYCLOSE, &CMFCsrialportDlg::onThreadClosed)
	ON_MESSAGE(WM_MYRECEIVE, &CMFCsrialportDlg::onReceive)

	ON_CBN_SELCHANGE(IDC_COMBO_COMPORT, &CMFCsrialportDlg::OnCbnSelchangeComboComport)

	ON_BN_CLICKED(IDC_BT_CLEAR, &CMFCsrialportDlg::OnBnClickedBtClear)
	ON_BN_CLICKED(IDC_BT_SEND, &CMFCsrialportDlg::OnBnClickedBtSend)
	ON_BN_CLICKED(IDC_BT_CONNECT, &CMFCsrialportDlg::OnBnClickedBtConnect)

	ON_EN_CHANGE(IDC_EDIT_SEND_DATA, &CMFCsrialportDlg::OnEnChangeEditSendData)
	ON_EN_UPDATE(IDC_EDIT_SEND_DATA, &CMFCsrialportDlg::OnUpdateEditSendData)
	ON_EN_KILLFOCUS(IDC_EDIT_SEND_DATA, &CMFCsrialportDlg::OnKillfocusEditSendData)
	ON_BN_CLICKED(IDC_BT_SEND_CLEAR, &CMFCsrialportDlg::OnBnClickedBtSendClear)
	ON_BN_CLICKED(IDC_BT_GET_CAS_FILE, &CMFCsrialportDlg::OnBnClickedBtGetCasFile)
	ON_BN_CLICKED(IDC_BT_SEND_CAS, &CMFCsrialportDlg::OnBnClickedBtSendCas)

	ON_BN_CLICKED(IDC_BT_GET_SERIAL, &CMFCsrialportDlg::OnBnClickedBtGetSerial)
	ON_BN_CLICKED(IDC_BT_GET_CAS, &CMFCsrialportDlg::OnBnClickedBtGetCas)
END_MESSAGE_MAP()


// CMFCsrialportDlg 메시지 처리기

BOOL CMFCsrialportDlg::OnInitDialog()
{
	CDialogEx::OnInitDialog();

	// 이 대화 상자의 아이콘을 설정합니다.  응용 프로그램의 주 창이 대화 상자가 아닐 경우에는
	//  프레임워크가 이 작업을 자동으로 수행합니다.
	SetIcon(m_hIcon, TRUE);			// 큰 아이콘을 설정합니다.
	SetIcon(m_hIcon, FALSE);		// 작은 아이콘을 설정합니다.

									// TODO: 여기에 추가 초기화 작업을 추가합니다.

	mGetSerialPort();

	comport_state = false;
	GetDlgItem(IDC_BT_CONNECT)->SetWindowText(_T("OPEN"));
		m_str_baudrate = _T("115200");
	UpdateData(FALSE);
	mUpdateButton(false);

	pEdit_send_data = (CEdit*)GetDlgItem(IDC_EDIT_SEND_DATA);

	//---Font
	LOGFONT lf;
	CFont* pFont = CFont::FromHandle((HFONT)GetStockObject(DEFAULT_GUI_FONT));
	pFont->GetLogFont(&lf);
	printf("%s\n", lf.lfFaceName);

	//CFont m_font;
	//m_font.CreatePointFont(500, lf.lfFaceName);
	//GetDlgItem(IDC_STATIC_PATH)->SetFont(&m_font);



	//---Init
	mStrCasPath = "";
	mIntCurNumber = 0;
	mIntTotalNumber = -1;
	mStrCasPath = _T("");		//CAS DB Full Path
	mStrCasFileName = _T("");;	//CAS DB File Name
	mStrCasKey = _T("");

	mLoadCASPath();
	mLoadCASCount();
	mGetCASID();
	mUpdatePath(mStrCasPath);
	mUpdateCasID();

	return TRUE;  // 포커스를 컨트롤에 설정하지 않으면 TRUE를 반환합니다.
}

// 대화 상자에 최소화 단추를 추가할 경우 아이콘을 그리려면
//  아래 코드가 필요합니다.  문서/뷰 모델을 사용하는 MFC 응용 프로그램의 경우에는
//  프레임워크에서 이 작업을 자동으로 수행합니다.

void CMFCsrialportDlg::OnPaint()
{
	if (IsIconic())
	{
		CPaintDC dc(this); // 그리기를 위한 디바이스 컨텍스트입니다.

		SendMessage(WM_ICONERASEBKGND, reinterpret_cast<WPARAM>(dc.GetSafeHdc()), 0);

		// 클라이언트 사각형에서 아이콘을 가운데에 맞춥니다.
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// 아이콘을 그립니다.
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialogEx::OnPaint();
	}
}

// 사용자가 최소화된 창을 끄는 동안에 커서가 표시되도록 시스템에서
//  이 함수를 호출합니다.
HCURSOR CMFCsrialportDlg::OnQueryDragIcon()
{
	return static_cast<HCURSOR>(m_hIcon);
}

LRESULT CMFCsrialportDlg::onThreadClosed(WPARAM length, LPARAM lpara)
{
	((CMycomm*)lpara)->HandleClose();
	delete ((CMycomm*)lpara);

	return 0;
}
LRESULT CMFCsrialportDlg::onReceive(WPARAM length, LPARAM lpara)
{
	CString str;
	char data[20000];
	if (m_comm)
	{
		m_comm->Receive(data, length);
		//data[length] = _T('\0');
		//str += _T("\r\n");
		//printf("onReceive : %d", length);

		//printf("%02x   %02x   %02x   %02x   %02x   %02x   %02x   %02x   %02x   %02x   %02x   %02x   %02x",
			//data[0], data[1], data[2], data[3], data[4], data[5], data[6], data[7], data[8], data[9], data[10], data[11],data[12]);
		parsing(data, length);
		/*
		for (int i = 0; i < length; i++)
		{
		str += data[i];
		}
		m_edit_rcv_view.ReplaceSel(str);
		str = "";

		m_edit_rcv_view.LineScroll(m_edit_rcv_view.GetLineCount());
		*/
	}
	return 0;
}


void CMFCsrialportDlg::OnBnClickedBtConnect()
{
	//printf("OnBnClickedBtConnect");
	// TODO: 여기에 컨트롤 알림 처리기 코드를 추가합니다.
	if (comport_state)
	{
		if (m_comm)
		{
			mUartConnect = false;
			m_comm->Close();
			m_comm = NULL;
			//AfxMessageBox(_T("COM Close"));
			comport_state = false;
			GetDlgItem(IDC_BT_CONNECT)->SetWindowText(_T("OPEN"));

			mUpdateButton(false);
		}
	}
	else
	{
		//printf("m_str_comport : " ,m_str_comport);
		m_comm = new CMycomm(_T("\\\\.\\") + m_str_comport, m_str_baudrate, _T("None"), _T("8 Bit"), _T("1 Bit"));
		if (m_comm->Create(GetSafeHwnd()) != 0)
		{
			mUpdateButtonConnect(FALSE);

			mUartConnect = false;
			CString strBarCode = _T("ERROR!");
			m_comm->Send(CMD1_VALUE, CMD_SET_CONNECT, strBarCode);

			SetTimer(MY_TIMER, 1000, 0);
						
			//GetDlgItem(IDC_BT_CONNECT)->SetWindowText(_T("CLOSE"));
			//GetDlgItem(IDC_BT_SEND)->EnableWindow(true);
		}
		else
		{
			AfxMessageBox(_T("ERROR!"));
		}
	}
}

void CMFCsrialportDlg::mUpdateConnect()
{
	CString str = _T("");
	if(mUartConnect) {
		comport_state = true;
		GetDlgItem(IDC_BT_CONNECT)->SetWindowText(_T("CLOSE"));

		str = "Port Open Success\r\n";

		mUpdateButton(true);
	}
	else {
		mUartConnect = false;
		m_comm->Close();
		m_comm = NULL;
		comport_state = false;
		GetDlgItem(IDC_BT_CONNECT)->SetWindowText(_T("OPEN"));

		str = "Port Open Fail\r\n";

		mUpdateButton(false);
	}
	m_edit_rcv_view.SetSel(0, 0);
	m_edit_rcv_view.ReplaceSel(str + "\r\n" + "\r\n");

	
	mUpdateButtonConnect(TRUE);
	
}


void CMFCsrialportDlg::OnTimer(UINT_PTR nIDEvent)
{
	switch (nIDEvent)
	{
		case MY_TIMER:
			//1초마다 처리할 내용
			mUpdateConnect();
			KillTimer(MY_TIMER);
			break;
	}
}

void CMFCsrialportDlg::OnCbnSelchangeComboComport()
{
	// TODO: 여기에 컨트롤 알림 처리기 코드를 추가합니다.
	UpdateData();
}
void CMFCsrialportDlg::OnCbnSelchangeComboBaudrate()
{
	// TODO: 여기에 컨트롤 알림 처리기 코드를 추가합니다.
	UpdateData();
}


void CMFCsrialportDlg::OnBnClickedBtClear()
{
	// TODO: 여기에 컨트롤 알림 처리기 코드를 추가합니다.
	GetDlgItem(IDC_EDIT_RCV_VIEW)->SetWindowText(_T(" "));
}


void CMFCsrialportDlg::OnBnClickedBtSend()
{
	// TODO: 여기에 컨트롤 알림 처리기 코드를 추가합니다.
	CString strBarCode;
	GetDlgItem(IDC_EDIT_SEND_DATA)->GetWindowText(strBarCode);
	
	strBarCode.Replace("\r", "");
	strBarCode.Replace("\n", "");
	m_comm->Send(CMD1_VALUE, CMD_SET_BARCODE, strBarCode);
}

byte PACKET_SOP = (byte)0xAA;
byte PACKET_EOP = (byte)0x55;
const byte PACKET_TYPE_NORMAL = (byte)0x01;
boolean bSOP = false;
boolean bLength = false;
boolean bLength2 = false;
int nLength = 0;
int nType = 0;
CArray <byte> mPacket;
void CMFCsrialportDlg::parsing(char *arg0, int size) {
	//		public void onReceive(byte[] arg0) throws RemoteException {
	// TODO Auto-generated method stub
	//			Log.d("debug", "=>[3] MCU -> APP onReceive");
	byte *buf = (byte*)arg0;

	//printf("\n %02x  %02x   %02x   %02x   %02x   %02x   %02x",
		//arg0[0], arg0[1], arg0[2], arg0[3], arg0[4], arg0[5], arg0[6]);
	int len = sizeof(arg0) / sizeof(arg0[0]);

	for (int i = 0; i<size; i++) {
		//printf("\n%02x  ", buf[i]);
		if (bSOP == false) {
			if (buf[i] == (byte)PACKET_SOP && (mPacket.GetSize() == 0 || mPacket.GetAt(mPacket.GetSize() -1) == PACKET_EOP)) {

				bSOP = true;
				bLength = false;
				nType = nLength = 0;
				mPacket.SetSize(0);
				mPacket.Add(buf[i]);
			}
		}
		else if (nType == 0) {
			switch (buf[i]) {
			case PACKET_TYPE_NORMAL:
				nType = buf[i];
				mPacket.Add(buf[i]);
				break;
			default:
				nType = nLength = 0;
				bLength = bSOP = false;
				break;
			}
		}
		else if (bLength == false) {
			bLength = true;
			nLength = buf[i];
			mPacket.Add(buf[i]);
		}
		else {
			mPacket.Add(buf[i]);
			if (mPacket.GetSize() - 4 >= nLength) {
				
				if (mPacket.GetAt(nLength + 2) == (byte)MakeCRC()) {
					printf("\n Packet Checksum  %d", mPacket.GetAt(1));
					//                            if(DEBUG) Log.d(TAG, "Recv - Type: " + mPacket.get(1) + " Len: " + mPacket.get(2) + " CMD-H: " + mPacket.get(3) + " CMD-L: " + mPacket.get(4));
					switch (mPacket.GetAt(1)) {
					case PACKET_TYPE_NORMAL:
						byte *data = new byte[mPacket.GetAt(2) - 3];
						for (int index = 5; index < mPacket.GetSize() - 2; index++)
							data[index - 5] = mPacket.GetAt(index);

						mUpdateList(mPacket.GetAt(3), mPacket.GetAt(4), data, mPacket.GetAt(2) - 3);
						//onDataReceived(mPacket.get(3), mPacket.get(4), data);

						break;
				
					}
				}
				else {
					//                            if(DEBUG) {2
					//                                Log.d(TAG, "Packet Checksum Error");
					//                                String str = "Recv : ";
					//                                for(int k = 0; k < mPacket.size(); k++)
					//                                    str += String.format("%02X " , (byte)mPacket.get(k));
					//                                Log.d(TAG, str);
					//                            }
					printf("\n Packet Checksum Error ");
				}
				printf("<<<<<<<<<<<<<<<<<");
				bSOP = bLength = false;
				nType = nLength = 0;
			}
		}
	}
}

byte CMFCsrialportDlg::MakeCRC() {
	//printf("\n +++ MakeCRC");
	int ret = 0;
	int sum = 0;
	if (mPacket.GetSize() < 3)
		return -1;

	for (int i = 0; i < mPacket.GetAt(2); i++) {
		sum = (sum + (byte)mPacket.GetAt(i + 2)) & 0xFF;
		printf("\n %d     sum : %d ", (byte)mPacket.GetAt(i + 2), sum);
	}
	ret = ~(sum) & 0xFF;
	printf("CRC = %02x \n ", ret);
	return (byte)ret;
}


void CMFCsrialportDlg::mUpdateList(byte _cmd1, byte _cmd2, byte * data, int size) {
	CString str = "";
	int len = (sizeof(data) / sizeof(data[0]));

	for (int i = 0; i < size; i++)	str += data[i];

	if (_cmd1 == CMD1_VALUE) {
		if (_cmd2 == CMD_SET_REPORT) SaveFile(str);
		else if (_cmd2 == CMD_SET_CONNECT) {
			mUartConnect = true;
			mUpdateConnect();
			KillTimer(MY_TIMER);
			return;
		}
		else if (_cmd2 == CMD_SET_CAS_ID) {
			int ret = str.Find(_T("Write : OK"));
			if (ret != -1) {
				mIntCurNumber++;
				mSaveCASCount();
				if (mIntTotalNumber > mIntCurNumber)	mGetCASID();
				else 									GetDlgItem(IDC_BT_SEND_CAS)->EnableWindow(false);
			}
		}
	}
		
	str.Replace("\n", "\r\n");
	m_edit_rcv_view.SetSel(0,0 ); // 커서를 끝부분으로 이동..
	m_edit_rcv_view.ReplaceSel(str + "\r\n" + "\r\n");

	//m_edit_rcv_view.LineScroll(m_edit_rcv_view.GetLineCount());
}

void CMFCsrialportDlg::SaveFile(CString _str) 
{
	printf("\n\n\n[OnBnClickedBtnSave] %s \n", _str);
	CString m_strPath;
	CStdioFile file;
	// CFile file;
	CFileException ex;
	//CFileDialog dlg(FALSE, _T("*.txt"), NULL, OFN_FILEMUSTEXIST | OFN_OVERWRITEPROMPT, _T("TXT Files(*.txt)|*.txt|"), NULL);
	//if (dlg.DoModal() == IDOK)
	myUtil_CheckDir("C:\\Reprot");
	{
		//m_strPath = dlg.GetPathName();
		m_strPath = "C:\\Reprot\\HRPU_REPORT.txt";
		printf("%s", m_strPath);
		/*
		if (m_strPath.Right(4) != ".txt")
		{
			m_strPath += ".txt";
		}
		*/

		file.Open(m_strPath, CFile::modeCreate | CFile::modeNoTruncate | CFile::modeReadWrite, &ex);

		// 에디트 박스에 있는 것을 저장한다. 

		file.SeekToEnd();

		file.WriteString(_str + _T("\n") + _T("\n"));

		// 종료한다. 
		file.Close();

	}
}


BOOL CMFCsrialportDlg::myUtil_CheckDir(CString sDirName)
{
	CFileFind file;
	CString strFile = "*.*";
	BOOL bResult = file.FindFile(sDirName + strFile);

	if (!bResult)
	{
		bResult = CreateDirectory(sDirName + "\\", NULL);
		if (!bResult)
		{
			/*Error*/
			return FALSE;
		}
		return TRUE;
	}
	return FALSE;
}

BOOL DeleteDirectoryFile(LPCTSTR RootDir)
{
	if (RootDir == NULL)
	{
		return FALSE;
	}

	BOOL bRval = FALSE;

	CString szNextDirPath = _T("");
	CString szRoot = _T("");


	// 해당 디렉토리의 모든 파일을 검사한다.
	szRoot.Format(_T("%s\\*.*"), RootDir);

	CFileFind find;

	bRval = find.FindFile(szRoot);

	if (bRval == FALSE)
	{
		return bRval;
	}

	while (bRval)
	{
		bRval = find.FindNextFile();

		// . or .. 인 경우 무시 한다.  
		if (find.IsDots() == FALSE)
		{
			// Directory 일 경우 재귀호출 한다.
			if (find.IsDirectory())
			{
				DeleteDirectoryFile(find.GetFilePath());
			}
			// file일 경우 삭제 
			else
			{
				bRval = DeleteFile(find.GetFilePath());
			}
		}
	}
	find.Close();
	bRval = RemoveDirectory(RootDir);
	return bRval;
}

void CMFCsrialportDlg::OnEnChangeEditSendData()
{
	// TODO:  RICHEDIT 컨트롤인 경우, 이 컨트롤은
	// CDialogEx::OnInitDialog() 함수를 재지정 
	//하고 마스크에 OR 연산하여 설정된 ENM_CHANGE 플래그를 지정하여 CRichEditCtrl().SetEventMask()를 호출하지 않으면
	// 이 알림 메시지를 보내지 않습니다.

	// TODO:  여기에 컨트롤 알림 처리기 코드를 추가합니다.
	/*
	pEdit_send_data->SetSel(-1, -1);
	int nLineCount = pEdit_send_data->GetLineCount();
	printf("%d", nLineCount);

	if(nLineCount > 2) {
	
	
	TCHAR temp[512 + 1];
	//첫줄 지우기
	int len = pEdit_send_data->GetLine(0, temp, _countof(temp)-1); //이 부분좀 개선의 여지가 있음(temp 는 사용되지 않음) 
	pEdit_send_data->SetSel(0, len+2);
	pEdit_send_data->ReplaceSel(_T(""));
	*/
	
}


void CMFCsrialportDlg::OnUpdateEditSendData()
{
	// TODO:  RICHEDIT 컨트롤인 경우, 이 컨트롤은
	// CDialogEx::OnInitDialog() 함수를 재지정 
	//하여, IParam 마스크에 OR 연산하여 설정된 ENM_SCROLL 플래그를 지정하여 컨트롤에 EM_SETEVENTMASK 메시지를 보내지 않으면
	// 편집 컨트롤이 바뀐 텍스트를 표시하려고 함을 나타냅니다.

	// TODO:  여기에 컨트롤 알림 처리기 코드를 추가합니다.
}


void CMFCsrialportDlg::mGetSerialPort()
{

	HKEY h_CommKey;
	LONG Reg_Ret;
	DWORD Size = MAX_PATH;
	char i_str[MAX_PATH];

	Reg_Ret = RegOpenKeyEx(HKEY_LOCAL_MACHINE, "HARDWARE\\DEVICEMAP\\SERIALCOMM", 0, KEY_READ | KEY_QUERY_VALUE, &h_CommKey);
	//레지스트리..

	if (Reg_Ret == ERROR_SUCCESS)
	{
		for (int i = 0; Reg_Ret == ERROR_SUCCESS; i++)
		{
			Reg_Ret = RegEnumValue(h_CommKey, i, i_str, &Size, NULL, NULL, NULL, NULL);
			if (Reg_Ret == ERROR_SUCCESS)
			{
				DWORD dwType, dwSize = MAX_PATH;
				char szBuffer[MAX_PATH];

				RegQueryValueEx(h_CommKey, i_str, 0, &dwType, (LPBYTE)szBuffer, &dwSize);
				printf("key : %s\n", szBuffer);
				m_str_comport = szBuffer;
				
				m_combo_comport_list.AddString(szBuffer);  // 리스트 박스에 레지스트리 내용 추가(여기서는 COM PORT)
													//하위 레지스트리 값을 얻을 수 있음. 
			}
			Size = MAX_PATH;
		}
	}
	RegCloseKey(h_CommKey);



}


void CMFCsrialportDlg::OnKillfocusEditSendData()
{
	// TODO: 여기에 컨트롤 알림 처리기 코드를 추가합니다.

}


void CMFCsrialportDlg::OnBnClickedBtSendClear()
{
	// TODO: 여기에 컨트롤 알림 처리기 코드를 추가합니다.
	GetDlgItem(IDC_EDIT_SEND_DATA)->SetWindowTextA("");
	GetDlgItem(IDC_EDIT_SEND_DATA)->SetFocus();
}


char *replaceAll(char *s, const char *olds, const char *news);

void CMFCsrialportDlg::OnBnClickedBtGetCasFile()
{
	// TODO: 여기에 컨트롤 알림 처리기 코드를 추가합니다.
	CFileDialog dlg(TRUE, NULL, NULL, OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT, _T("ALL Files(*.*)|*.*|"), NULL);
	if (dlg.DoModal() == IDOK) {
		mStrCasPath = dlg.GetPathName();
		mStrCasFileName = dlg.GetFileName();
		mStrCasFileName = dlg.GetFileName();


		//--Make File
		FILE * fp = NULL;
		fopen_s(&fp, mStrCasPath, "r");
		if (fp == NULL) NULL;

		char szContent[50] = { 0, };
		memset(szContent, NULL, 50);

		int count = 1;
		fseek(fp, 0, SEEK_SET);

		CString StrMakeFile = mStrCasPath;
//		StrMakeFile = StrMakeFile.TrimRight(mStrCasFileName);
	//	StrMakeFile = StrMakeFile + "file";
		int i = StrMakeFile.ReverseFind('.');//실행 파일 이름을 지우기 위해서 왼쪽에 있는 '/'를 찾는다.
		StrMakeFile = StrMakeFile.Left(i);//뒤에 있는 현재 실행 파일 이름을 지운다.
		StrMakeFile.Format("%s_%s", StrMakeFile, _T("folder"));

		DeleteDirectoryFile(StrMakeFile);
		myUtil_CheckDir(StrMakeFile);

		CString _fileName;
		char *s2;

		FILE * fpMake = NULL;
		while ((fgets(szContent, 50, fp))) {

			s2 = replaceAll(szContent, "\n", "");
			_fileName.Format("%s\\%d_%s.txt", StrMakeFile, count, s2);
			fopen_s(&fpMake, _fileName, "w");
			if (fpMake == NULL) break;;
			count++;
			fclose(fpMake);
		}
		fclose(fp);
		mUpdatePath(mStrCasPath);

		mSaveCASPath();

		mIntTotalNumber = -1;
		if (mLoadCASCount() == FALSE) mIntCurNumber = 0;
		mGetCASID();
	}
}

char *replaceAll(char *s, const char *olds, const char *news) {
	char *result, *sr;
	size_t i, count = 0;
	size_t oldlen = strlen(olds); if (oldlen < 1) return s;
	size_t newlen = strlen(news);


	if (newlen != oldlen) {
		for (i = 0; s[i] != '\0';) {
			if (memcmp(&s[i], olds, oldlen) == 0) count++, i += oldlen;
			else i++;
		}
	}
	else i = strlen(s);


	result = (char *)malloc(i + 1 + count * (newlen - oldlen));
	if (result == NULL) return NULL;


	sr = result;
	while (*s) {
		if (memcmp(s, olds, oldlen) == 0) {
			memcpy(sr, news, newlen);
			sr += newlen;
			s += oldlen;
		}
		else *sr++ = *s++;
	}
	*sr = '\0';

	return result;
}


void CMFCsrialportDlg::mGetCASID()
{
	if (mStrCasPath.GetLength() <= 0) return;
	mStrCasKey = "";
	mUpdateCasID();

	FILE * fp = NULL;
	fopen_s(&fp, mStrCasPath, "r");
	if (fp == NULL) return;

	char szContent[50] = { 0, };
	memset(szContent, NULL, 50);

	if(mIntTotalNumber == -1) {
		fseek(fp, 0, SEEK_END);

		int nTotalLen = ftell(fp);
		if (nTotalLen < 12)	mIntTotalNumber = 0;
		else				mIntTotalNumber = nTotalLen / 12 + 1;
	}

	fseek(fp, mIntCurNumber * 12, SEEK_SET);
	if (fgets(szContent, 50, fp))
	{
		printf("%s", szContent);
		mStrCasKey = szContent;
		mStrCasKey.Replace("\n", "");
	}
	else {
		GetDlgItem(IDC_BT_SEND_CAS)->EnableWindow(false);
	}
	fclose(fp);

	mUpdateCasID();
}




void CMFCsrialportDlg::OnBnClickedBtSendCas()
{
	// TODO: 여기에 컨트롤 알림 처리기 코드를 추가합니다.
	// TODO: 여기에 컨트롤 알림 처리기 코드를 추가합니다.
	CString str;
	GetDlgItem(IDC_STATIC_CAS)->GetWindowText(str);

	str.Replace("\r", "");
	str.Replace("\n", "");
	printf("CAS ID : %s\n", str);
	//printf("send : %s\n", ConvertToHex(str));
	
	m_comm->Send(CMD1_VALUE, CMD_SET_CAS_ID, str);
}

//-----------------Update
void CMFCsrialportDlg::mUpdateCasID()
{
	GetDlgItem(IDC_STATIC_CAS)->SetWindowText(mStrCasKey);

	CString str;

	if (mIntTotalNumber == -1)						str = _T("");
	else if (mIntCurNumber + 1 > mIntTotalNumber)	str.Format("%d / %d", mIntCurNumber, mIntTotalNumber);
	else											str.Format("%d / %d", mIntCurNumber + 1, mIntTotalNumber);
	GetDlgItem(IDC_STATIC_CAS_COUNT)->SetWindowText(str);

}

void CMFCsrialportDlg::mUpdatePath(CString _path)
{
	GetDlgItem(IDC_STATIC_PATH)->SetWindowText(_path);
}

void CMFCsrialportDlg::mUpdateButton(BOOL _flag)
{
	GetDlgItem(IDC_BT_SEND)->EnableWindow(_flag);
	GetDlgItem(IDC_BT_SEND_CAS)->EnableWindow(_flag);
	GetDlgItem(IDC_BT_GET_SERIAL)->EnableWindow(_flag);
	GetDlgItem(IDC_BT_GET_CAS)->EnableWindow(_flag);

	if (_flag && mIntCurNumber + 1 > mIntTotalNumber) {
		GetDlgItem(IDC_BT_SEND_CAS)->EnableWindow(FALSE);
	}
}

void CMFCsrialportDlg::mUpdateButtonConnect(BOOL _flag)
{
	GetDlgItem(IDC_BT_CONNECT)->EnableWindow(_flag);
	GetDlgItem(IDC_COMBO_COMPORT)->EnableWindow(_flag);
}
//-----------------File
BOOL CMFCsrialportDlg::mLoadCASPath()
{
	TCHAR path[_MAX_PATH];
	GetModuleFileName(NULL, path, sizeof path);

	CString strPath = path;
	int i = strPath.ReverseFind('\\');//실행 파일 이름을 지우기 위해서 왼쪽에 있는 '/'를 찾는다.
	strPath = strPath.Left(i);//뒤에 있는 현재 실행 파일 이름을 지운다.
	strPath.Format("%s\\%s", strPath, _T("CAS_Path.txt"));

	//-----CAS 파일 위치
	FILE * fp = NULL;
	fopen_s(&fp, strPath, "r");
	if (fp == NULL) {
		return FALSE;
	}

	char szContent[255] = { 0, };
	memset(szContent, NULL, 255);

	fseek(fp, 0, SEEK_SET);

	if (fgets(szContent, 255, fp))
	{
		printf("%s", szContent);

		mStrCasPath = szContent;
		mStrCasPath.Replace("\n", "");
	}
	fclose(fp);
}
BOOL CMFCsrialportDlg::mLoadCASCount()
{
	if (mStrCasPath.GetLength() <= 0) return FALSE;

	//-----CAS COUNT
	char szContent[255] = { 0, };
	FILE * fp = NULL;
	CString strPath = mStrCasPath;
	int i = strPath.ReverseFind('.');//실행 파일 이름을 지우기 위해서 왼쪽에 있는 '/'를 찾는다.
	strPath = strPath.Left(i);//뒤에 있는 현재 실행 파일 이름을 지운다.
	strPath.Format("%s_count.txt", strPath);

	memset(szContent, NULL, 255);

	//-----CAS 파일 위치
	fopen_s(&fp, strPath, "r");
	if (fp == NULL) return FALSE;

	memset(szContent, NULL, 255);

	fseek(fp, 0, SEEK_SET);

	if (fgets(szContent, 255, fp))
	{
		printf("%s", szContent);

		strPath = szContent;
		strPath.Replace("\n", "");
		mIntCurNumber = _ttoi(strPath);
	}
	fclose(fp);

	return TRUE;
}
void CMFCsrialportDlg::mSaveCASPath()
{
	TCHAR path[_MAX_PATH];
	GetModuleFileName(NULL, path, sizeof path);

	CString strPath = path;
	int i = strPath.ReverseFind('\\');//실행 파일 이름을 지우기 위해서 왼쪽에 있는 '/'를 찾는다.
	strPath = strPath.Left(i);//뒤에 있는 현재 실행 파일 이름을 지운다.
	strPath.Format("%s\\%s", strPath, _T("CAS_Path.txt"));

	//-----CAS 파일 위치
	FILE * fp = NULL;
	fopen_s(&fp, strPath, "w");
	if (fp == NULL) {
		return;
	}
	fputs(LPSTR(LPCTSTR(mStrCasPath)), fp);
	fclose(fp);
}
void CMFCsrialportDlg::mSaveCASCount()
{
	//-----CAS COUNT
	CString strPath = mStrCasPath;
	int i = strPath.ReverseFind('.');//실행 파일 이름을 지우기 위해서 왼쪽에 있는 '/'를 찾는다.
	strPath = strPath.Left(i);//뒤에 있는 현재 실행 파일 이름을 지운다.
	strPath.Format("%s_count.txt", strPath);

	//-----CAS 파일 위치
	FILE * fp = NULL;
	fopen_s(&fp, strPath, "w");
	if (fp == NULL) {
		return;
	}
	CString _str;
	_str.Format("%d", mIntCurNumber);
	fputs(LPSTR(LPCTSTR(_str)), fp);

	fclose(fp);
}

void CMFCsrialportDlg::OnBnClickedBtGetSerial()
{
	// TODO: 여기에 컨트롤 알림 처리기 코드를 추가합니다.
	CString str = "get";
	m_comm->Send(CMD1_VALUE, CMD2_GET_SERIAL, str);
}


void CMFCsrialportDlg::OnBnClickedBtGetCas()
{
	// TODO: 여기에 컨트롤 알림 처리기 코드를 추가합니다.
	CString str = "get";
	m_comm->Send(CMD1_VALUE, CMD2_GET_CAS_ID, str);
}
